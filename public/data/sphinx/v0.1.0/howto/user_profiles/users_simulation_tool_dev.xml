<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE document PUBLIC "+//IDN docutils.sourceforge.net//DTD Docutils Generic//EN//XML" "http://docutils.sourceforge.net/docs/ref/docutils.dtd">
<!-- Generated by Docutils 0.16 -->
<document source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/user_profiles/users_simulation_tool_dev.rst">
    <target refid="users-simulation-tool-dev"></target>
    <section ids="simulation-tool-developer users-simulation-tool-dev" names="simulation\ tool\ developer users_simulation_tool_dev">
        <title>Simulation tool developer</title>
        <paragraph>The code generation functionality in libCellML can be used to transform CellML models into procedural code for simulation.
            This example works through that process.</paragraph>
        <paragraph><strong>Contents</strong></paragraph>
        <topic classes="contents local" ids="contents" names="contents">
            <bullet_list>
                <list_item>
                    <paragraph><reference ids="id1" refid="parse-an-existing-model-from-a-file">Parse an existing model from a file</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id2" refid="resolve-imports-and-flatten-model">Resolve imports and flatten model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id3" refid="validate-model">Validate model</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id4" refid="generate-code">Generate code</reference></paragraph>
                </list_item>
                <list_item>
                    <paragraph><reference ids="id5" refid="use-the-generated-code-to-simulate-the-model">Use the generated code to simulate the model</reference></paragraph>
                </list_item>
            </bullet_list>
        </topic>
        <line_block>
            <line><strong>C++ resources</strong></line>
            <line_block>
                <line>├ <download_reference filename="12cdcb42018001670dc9e0a397d4d1ff/CMakeLists.txt" refdoc="howto/user_profiles/users_simulation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/simulation_tool_dev/CMakeLists.txt" reftype="download" refwarn="False"><literal classes="xref download">CMakeLists.txt</literal></download_reference></line>
                <line>├ <download_reference filename="1a96c1f0e6f53dae07a6c0a6b32f1036/simulationToolDev.cpp" refdoc="howto/user_profiles/users_simulation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/simulation_tool_dev/simulationToolDev.cpp" reftype="download" refwarn="False"><literal classes="xref download">example_simulationToolDev.cpp</literal></download_reference></line>
                <line>└ resources/</line>
                <line_block>
                    <line>└ <download_reference filename="e2de8df04fb09256cd8a3c9fd355481d/simulationExample.cellml" refdoc="howto/user_profiles/users_simulation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/simulation_tool_dev/simulationExample.cellml" reftype="download" refwarn="False"><literal classes="xref download">simulationExample.cellml</literal></download_reference></line>
                </line_block>
            </line_block>
        </line_block>
        <line_block>
            <line><strong>Python resources</strong></line>
            <line_block>
                <line>├ <download_reference filename="5b3c7b36f7aedccc4adc246da4ad5d15/simulationToolDev.py" refdoc="howto/user_profiles/users_simulation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/simulation_tool_dev/simulationToolDev.py" reftype="download" refwarn="False"><literal classes="xref download">example_simulationToolDev.py</literal></download_reference></line>
                <line>└ resources/</line>
                <line_block>
                    <line>└ <download_reference filename="e2de8df04fb09256cd8a3c9fd355481d/simulationExample.cellml" refdoc="howto/user_profiles/users_simulation_tool_dev" refdomain="" refexplicit="True" reftarget="../code/simulation_tool_dev/simulationExample.cellml" reftype="download" refwarn="False"><literal classes="xref download">simulationExample.cellml</literal></download_reference></line>
                </line_block>
            </line_block>
        </line_block>
        <section ids="parse-an-existing-model-from-a-file" names="parse\ an\ existing\ model\ from\ a\ file">
            <title refid="id1">Parse an existing model from a file</title>
            <paragraph>The following code will read a file called <literal classes="code">simulationExample.cellml</literal> and deserialise its contents into a <literal classes="code">Model</literal> instance.
                Note that both the <literal classes="code">Parser</literal> class and its opposite number, the <literal classes="code">Printer</literal> class, deal with strings rather than files.
                You’ll need to read the file into a string, and then use the string as input to the <literal classes="code">Parser</literal> item.</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/simulation_tool_dev/simulationToolDev.cpp" xml:space="preserve">    // Parse a CellML file into a model.

    // Read the file containing the CellML model into a string.
    std::string inFileName = "simulationExample.cellml";
    std::ifstream inFile(inFileName);
    std::stringstream inFileContents;
    inFileContents &lt;&lt; inFile.rdbuf();

    std::cout &lt;&lt; "Opening the CellML file" &lt;&lt; std::endl;

    // Create a libCellML Parser, and use it to parse the fileContents
    // string and convert it into a CellML Model structure.
    auto parser = libcellml::Parser::create();
    auto model = parser-&gt;parseModel(inFileContents.str());
    printIssues(parser);

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-0-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/simulation_tool_dev/simulationToolDev.py" xml:space="preserve">    # Parse the model from a CellML file.

    # Create a libCellML Parser, and use it to parse the fileContents
    # string and convert it into a CellML Model structure.
    read_file = open("resources/simulationExample.cellml", "r")
    parser = Parser()
    model = parser.parseModel(read_file.read())
    print_issues_to_terminal(parser)

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="resolve-imports-and-flatten-model" names="resolve\ imports\ and\ flatten\ model">
            <title refid="id2">Resolve imports and flatten model</title>
            <paragraph>The import functionality for <literal classes="code">Units</literal> and <literal classes="code">Component</literal> items is key to enabling the reuse and sharing of models.
                The import statements are basically a recipe for how these imported items can be combined to make the present model.
                While models which contain import dependencies are perfectly valid, they cannot be used to generate runnable code.
                The process of resolving the imports (telling libCellML where to look for these ingredients) and flattening the model (creating instances of the ingredients and removing the dependency) is necessary before code generation can happen.</paragraph>
            <paragraph>The <literal classes="code">Importer</literal> class supports all functionality to do with imports, and contains its own logger which can be used to report anything that might have gone wrong.</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/simulation_tool_dev/simulationToolDev.cpp" xml:space="preserve">    // Resolve the import dependencies (if any) and flatten the model.

    if(model-&gt;hasUnresolvedImports()) {
        auto importer = libcellml::Importer::create();

        // Submit the model to the importer and the absolute location 
        // against which the import reference paths will be resolved.
        importer-&gt;resolveImports(model, "");

        printIssues(importer);

        // Print a list of dependencies for the current unflattened model.
        printImportDependencies(model);

        // Retrieve a "flattened" (ie: import-free) model from the importer,
        // and use it to over-write the current model.cd 
        model = importer-&gt;flattenModel(model);

        printImportDependencies(model);
    }

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-1-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/simulation_tool_dev/simulationToolDev.py" xml:space="preserve">    # Resolve any import dependencies (if present) in the model.

    if(model.hasUnresolvedImports()) {

        # Create an Importer instance.
        importer = Importer()

        # Submit the model to the importer and the absolute location 
        # against which the import reference paths will be resolved.
        importer.resolveModelImports(model, "resources/")
        print_issues_to_terminal(importer)

        # Print a list of sources that this model requires. This list will 
        # be empty after the model has been flattened.
        print_import_dependencies(model)

        # Retrieve a "flattened" (ie: import-free) model from the importer,
        # and use it to over-write the current model.
        model = importer.flattenModel(model)
    }

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="validate-model" names="validate\ model">
            <title refid="id3">Validate model</title>
            <paragraph>The <literal classes="code">Validator</literal> is the equivalent of a spelling checker: it can check that each item in a model has all of the information it needs, but it can’t check whether it means what you intend it to.
                Thus even if a model is valid, it could still be the equivalent of correctly-spelled nonsense.</paragraph>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/simulation_tool_dev/simulationToolDev.cpp" xml:space="preserve">    // Validate the model: check for syntactic and semantic errors.

    // Create a Validator instance and pass the model for checking.
    auto validator = libcellml::Validator::create();
    validator-&gt;validateModel(model);
    auto isValid = validator-&gt;errorCount() == 0;
    printIssues(validator);

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-2-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/simulation_tool_dev/simulationToolDev.py" xml:space="preserve">    # Validate the model: check for syntactic and semantic errors.

    # Create a Validator instance and pass the model for checking.
    validator = Validator()
    validator.validateModel(model)
    print_issues_to_terminal(validator)

</literal_block>
                    </container>
                </container>
            </container>
            <paragraph>Once a model has been passed to a <literal classes="code">Validator</literal> instance, the validator’s internal logger will contain a list of any of the issues which have been encountered during the checking process.
                A model can be said to be valid - that is, conforming to the <reference internal="False" refuri="https://cellml-specification.readthedocs.io/en/latest/">CellML normative specification</reference> - if the validator’s logger contains no issues with a level of <literal classes="code">ERROR</literal>.</paragraph>
            <paragraph>For more information on how to use any of the classes which record issues, please see the <reference internal="True" refuri="../actions/get_issues#actions-get-issues"><inline classes="std std-ref">Get Issues</inline></reference> section.</paragraph>
        </section>
        <section ids="generate-code" names="generate\ code">
            <title refid="id4">Generate code</title>
            <paragraph>Code generation is the process of representing the CellML model in another language format.
                At the time of writing, two profiles are available: C (default) and Python.
                There are four steps to code generation:</paragraph>
            <enumerated_list enumtype="arabic" prefix="" suffix=".">
                <list_item>
                    <paragraph>Create a <literal classes="code">Generator</literal> item and select the profile language.
                        (The default profile is C).</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Pass a model to the generator for processing.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>Retrieve the generated implementation code.
                        This is the contents of the <literal classes="code">*.c</literal> file (if C is the profile) or <literal classes="code">*.py</literal> if Python is selected.</paragraph>
                </list_item>
                <list_item>
                    <paragraph>(optional) Retrieve the generated interface code.
                        This is the contents of the <literal classes="code">*.h</literal> file, and is not required for the Python profile.</paragraph>
                </list_item>
            </enumerated_list>
            <container classes="sphinx-tabs">
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>C++ snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-0 active">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="c++" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/simulation_tool_dev/simulationToolDev.cpp" xml:space="preserve">    // Analyse the model: check for mathematical and modelling errors.
    auto analyser = libcellml::Analyser::create();
    analyser-&gt;analyseModel(model);
    printIssues(analyser);

</literal_block>
                    </container>
                </container>
                <container classes="dummy">
                    <container classes="item">
                        <container classes="dummy">
                            <paragraph>Python snippet</paragraph>
                        </container>
                    </container>
                    <container classes="ui bottom attached sphinx-tab tab segment sphinx-data-tab-3-1">
                        <literal_block force="False" highlight_args="{'linenostart': 1}" language="python" linenos="False" source="/Users/kmoy001/libcellml/libcellml-tutorials/howto/code/simulation_tool_dev/simulationToolDev.py" xml:space="preserve">    # Analyse a model: check for mathematical and modelling errors.
    analyser = Analyser()
    analyser.analyseModel(model)
    print_issues_to_terminal(analyser)

</literal_block>
                    </container>
                </container>
            </container>
        </section>
        <section ids="use-the-generated-code-to-simulate-the-model" names="use\ the\ generated\ code\ to\ simulate\ the\ model">
            <title refid="id5">Use the generated code to simulate the model</title>
            <paragraph>Instructions for a simple solver to solve the model can be found on the <reference internal="True" refuri="users_solver#users-solver"><inline classes="std std-ref">Simulation tool developer: Solver</inline></reference> page.</paragraph>
        </section>
    </section>
</document>
